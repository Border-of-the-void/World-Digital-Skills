#include <Servo.h>                                                        //подключение массивы для работы с сервоприводами      
Servo servo[5];                                                           //создание массива сервоприводов
int C = 0;                                                                //счётчик жестов
boolean Working = 1;                                                      //переменная для аварийного режима
long int Time[3] = {0, 0, 0};                                             //текущее время, время 1 датчика, время 2 датчика
int emg[2][64];                                                           //двумерный массив, который содержит последние 64 показания с 1 и 2 датчиков
int amp[2] = {0, 0};                                                      //амплитуда 1 и 2 датчкиов
int Max[2];                                                               //максимальные из 64 показаний 1 и 2 датчиков
int Min[2];                                                               //минимальные из 64 показаний 1 и 2 датчиков
int th[2];                                                                //тресхолд, регулируемый потенциометром
int Button[3] = {0, 0, 1};                                                //текущее состояние кнопки, прошлое состояние кнопки, была ли кнопка отжата после входа в аварийный режим
long int ButtonTime = 0;                                                  //время последнего нажатия кнопки
int Pins[5] {2, 4, 11, 12, 13};                                           //диджитал порты, которые используются на выход
float Speed[5] = {1, 1, 1, 0.09, 0.3};                                    //скорости для сервоприводов
float Now[5] = {180, 3, 0, 172, 168};                                     //текущее положение сервоприводов
float Need[5];                                                            //необходимые углы сероприводов
int servoPins[5] = {3, 5, 6, 9, 10};                                      //пины сервоприводов
byte Leds[12] = {0b00000000,                                              //битная кодировка для сдвигового регистра
                 0b00000000,                                              //битная кодировка для сдвигового регистра
                 0b10000000,                                              //битная кодировка для сдвигового регистра
                 0b01000000,                                              //битная кодировка для сдвигового регистра
                 0b00100000,                                              //битная кодировка для сдвигового регистра
                 0b00010000,                                              //битная кодировка для сдвигового регистра
                 0b00001000,                                              //битная кодировка для сдвигового регистра
                 0b00000100,                                              //битная кодировка для сдвигового регистра
                 0b00000010,                                              //битная кодировка для сдвигового регистра
                 0b00000001,                                              //битная кодировка для сдвигового регистра
                 0b10101010,                                              //битная кодировка для сдвигового регистра
                 0b01010101};                                             //битная кодировка для сдвигового регистра
int Signs[10][5] = {{180, 3, 0, 172, 168},                                //Ладонь
                    {0, 3, 0, 172, 168},                                  //Тыдыщ
                    {180, 3, 0, 172, 168},                                //Ладонь
                    {0, 180, 180, 80, 0},                                 //Кулак
                    {180, 3, 0, 172, 168},                                //Ладонь
                    {180, 3, 120, 109, 86},                               //Ок
                    {180, 3, 0, 172, 168},                                //Ладонь
                    {0, 3, 2, 63, 72},                                    //Виктори
                    {180, 3, 0, 172, 168},                                //Ладонь
                    {0, 180, 0, 130, 150}};                               //Первый
                                                                          //
                                                                          //
void setup() {                                                            //функция сетап
  Serial.begin(9600);                                                     //открытие сериал порта
  for (int i = 0; i < 5; i++) {                                           //цикл от 0 до 5
    servo[i].attach(servoPins[i]);                                        //назначение сервоприводам соответсвующих пинов
  }                                                                       //конец цикла
  for (int i = 0; i < 5; i++) {                                           //цикл от 0 до 5
    pinMode(Pins[i], OUTPUT);                                             //назначение пинов на выход
  }                                                                       //конец цикла
  for (int i = 0; i < 64; i++) {                                          //цикл от 0 до 64
    emg[0][i] = analogRead(A0);                                           //заполнение массива показаниями 1 датчика
    emg[1][i] = analogRead(A1);                                           //заполнение массива показаниями 2 датчика
  }                                                                       //конец цикла
}                                                                         //конец функции
                                                                          //
                                                                          //
void Replace() {                                                          //функция изменения значения сервоприводов
  for (int i = 0; i < 5; i++)                                             //цикл от 0 до 5
    Need[i] = Signs[C][i];                                                //подсчёт необходимых углов
    Now[i] = servo[i].read();                                             //считывание текущих углов
    while (abs(Need[i] - Now[i]) >= Speed[i]) {                           //цикл изменения углов на величину скорости
      ButtonCheck();                                                      //проверка состояния кнопки
      if (Working == 0) {                                                 //если кнопка была нажата 
        break;                                                            //выход их цикла
      }                                                                   //конец условия
      Now[i] += Speed[i] * abs(Need[i] - Now[i]) / (Need[i] - Now[i]);    //уменьшение разницы между текущим углом и необходимым на величину скорости
      servo[i].write(Now[i]);                                             //запись нового значения
    }                                                                     //конец цикла
  }                                                                       //конец цикла
}                                                                         //конец функкции
                                                                          //
                                                                          //
void Led() {                                                              //функция изменения светодиодов
  digitalWrite(4, C == 0);                                                //светодиодная индикация когда счётчик равен 0
  digitalWrite(2, C == 1);                                                //светодиодная индикация когда счётчик равен 1
  digitalWrite(13, 0);                                                    //открытие латч порта
  shiftOut(12, 11, LSBFIRST, Leds[C]);                                    //запись новых значений в сдвиговый регистр
  digitalWrite(13, 1);                                                    //закрытие латч порта
}                                                                         //конец функции
                                                                          //
                                                                          //
void Amplitude() {                                                        //функция амплитуды
  th[0] = analogRead(A2);                                                 //снятие показаний 1 потенциометра
  th[1] = analogRead(A3);                                                 //снятие показаний 0 потенциометра
  for (int i = 0; i < 63; i++) {                                          //цикл от 0 до 63
    emg[0][i] = emg[0][i + 1];                                            //сдвиг значений в массиве
    emg[1][i] = emg[1][i + 1];                                            //сдвиг значений в массиве
  }                                                                       //конец цикла
  emg[0][63] = analogRead(A0);                                            //запись новых значений 1 датчика
  emg[1][63] = analogRead(A1);                                            //запись новых значений 0 датчика
  Max[0] = Max[1] = 0;                                                    //обнуление минимальных значений
  Min[0] = Min[1] = 1023;                                                 //обнуление максимальных значений
  for (int t = 0; t < 2; t ++) {                                          //цикл от 0 до 2
    for (int i = 0; i < 63; i++) {                                        //цикл от 0 до 63
      if (emg[t][i] > Max[t]) {                                           //если значение емг больше максимального
        Max[t] = emg[t][i];                                               //изменение максимального значения
      }                                                                   //конец условия
      if (emg[t][i] < Min[t]) {                                           //если значение емг меньше минимального
        Min[t] = emg[t][i];                                               //изменение минимального значения
      }                                                                   //конец условия
    }                                                                     //конец цикла
  }                                                                       //конец цикла
  amp[0] = amp[0] * 0.7 + (Max[0] - Min[0]) * 0.3;                        //расчёт амплитуды 1 датчика
  amp[1] = amp[1] * 0.7 + (Max[1] - Min[1]) * 0.3;                        //расчёт амплитуды 2 дачтика
}                                                                         //конец функции
                                                                          //
                                                                          //
void Act () {                                                             //функция изменения счётчика
  if (amp[0] > th[0] and Time[0] > Time[1]) {                             //если амплитуда 1 превышает потенциометр 1 и текущее время больше времени срабатывания датчика 1
    C = (C + 1) % 10;                                                     //увеличение счётчика на 1
    Time[1] = Time[0] + 2000;                                             //время срабатывания датчика 1 равно текущему +2с
  }                                                                       //конец условия
  if (amp[1] > th[1] and Time[0] > Time[2]) {                             //если амплитуда 2 превышает потенциометр 2 и текущее время больше времени срабатывания датчика 2
    C = (C + 9) % 10;                                                     //уменьшение счётчика на 1
    Time[2] = Time[0] + 2000;                                             //время срабатывания датчика 2 равно текущему +2с
  }                                                                       //конец условия
}                                                                         //конец функции
                                                                          //
                                                                          //
void Output() {                                                           //функция вывода значений в монитор порта или плоттер по последовательному соединеню
  for (int i = 0; i < 2; i++) {                                           //цикл от 0 до 2
    Serial.print(amp[i]);                                                 //вывод амплитуды со сзначением i
    Serial.print(',');                                                    //разделяющая запятая при выводе
    Serial.print(th[i]);                                                  //вывод показаний потенциометра со сзначением i
    Serial.print(',');                                                    //разделяющая запятая при выводе
  }                                                                       //конец цикла
  Serial.println(C * 100);                                                //вывод стократного увеличения счётчика для лучшего восприятия на графике
}                                                                         //конец функции
                                                                          //
                                                                          //
void ButtonCheck() {                                                      //
  Button[1] = Button[0];                                                  //
  Button[0] = digitalRead(7);                                             //
  if (Button[0] and not(Button[1])) {                                     //
    if (Working){                                                         //
      Button[3] = 0;                                                      //
    }                                                                     //
    Working = 0;                                                          //
    ButtonTime = Time[0] + 3000;                                          //
    Crash();                                                              //
  }                                                                       //
  if (Button[1] and not(Button[0])) {                                     //
    ButtonTime = Time[0] + 3000;                                          //
    Button[3] = 1;                                                        //
    Crash();                                                              //
  }                                                                       //
  if (Button[0] and Button[1] and Time[0] > ButtonTime and Button[3]) {   //
    Working = 1;                                                          //
    ButtonTime = Time[0] + 3000;                                          //
  }                                                                       //
}                                                                         //
                                                                          //
                                                                          //
void Work() {                                                             //
    Led();                                                                //
    Amplitude();                                                          //
    Act();                                                                //
    Replace();                                                            //
    Output();                                                             //
}                                                                         //
                                                                          //
                                                                          //
void Crash() {                                                            //
  for (int i = 0; i < 5; i++) {                                           //
    servo[i].write(Signs[0][i]);                                          //
  }                                                                       //
  digitalWrite(2, Time[0] % 250 / 125);                                   //
  digitalWrite(4, 1 - Time[0] % 250 / 125);                               //
  digitalWrite(13, 0);                                                    //
  shiftOut(12, 11, LSBFIRST, Leds[10 + Time[0] % 250 / 125]);             //
  digitalWrite(13, 1);                                                    //
}                                                                         //
                                                                          //
                                                                          //
void loop() {                                                             //
  Time[0] = millis();                                                     //
  ButtonCheck();                                                          //
  if (Working) {                                                          //
    Work();                                                               //
  }                                                                       //
  else {                                                                  //
    Crash();                                                              //
  }                                                                       //
}                                                                         //
